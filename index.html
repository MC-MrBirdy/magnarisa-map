<!DOCTYPE html>
<html>
  <head>
    <title>MagnaRisa 1.13+</title>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
	
    <link rel="stylesheet" href="leafletjs/leaflet.css">
    <link rel="stylesheet" href="leafletjs/L.Control.MousePosition.css">
    <link rel="stylesheet" href="leafletjs/leaflet-search.css">
    <link rel="stylesheet" href="leafletjs/leaflet-search.mobile.css">
	
	<script src="leafletjs/leaflet.js" type="text/javascript"></script>
    <script src="leafletjs/L.Control.MousePosition.js" type="text/javascript"></script>
	<script src="leafletjs/leaflet-search.js" type="text/javascript"></script>
	
	<script src="overworld/warps.js" type="text/javascript"></script>
	<script src="overworld/homes.js" type="text/javascript"></script>
	
    <style>
      html, body, #map { width:100%; height:100%; margin:0; padding:0; z-index: 1; background: grey; }
      #slider{ position: absolute; top: 10px; right: 10px; z-index: 5; }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <script type="text/javascript">		
		var mapMinZoom = 3;
		var mapMaxZoom = 6;
		var coCor = 1.2;

		var mapExtent = [-5120.00000000, -5120.00000000, 5120.00000000, 5120.00000000];
		var tileExtent = [-5120.00000000, -5120.00000000, 5120.00000000, 5120.00000000];

		var mapMaxResolution = 1.00000000;
		var mapMinResolution = Math.pow(2, mapMaxZoom) * mapMaxResolution;
		
		// Two functions to fix the coordinates displayed.
		// Lat needs to be reversed, else the coordinates are flipped.
		function lat(cor) {
			return Math.round(cor*coCor)*-1;
		}
		function lng(cor){
			return Math.round(cor*coCor);
		}

		var crs = L.CRS.Simple;
		crs.transformation = new L.Transformation(1, -tileExtent[0], -1, tileExtent[3]);
		crs.scale = function(zoom) {
			return Math.pow(2, zoom) / mapMinResolution;
		};
		crs.zoom = function(scale) {
			return Math.log(scale * mapMinResolution) / Math.LN2;
		};
	  
		document.addEventListener('DOMContentLoaded', (event) => {
		
			// Create the overworld-layer to display MagnaRisa.
			var overworld = L.tileLayer('overworld/{z}/{x}/{y}.png', {
				minZoom: mapMinZoom,
				maxZoom: mapMaxZoom,
				noWrap: true,
				tms: false
			});
			// Create the overworld-layer to display MagnaRisa.
			var nether = L.tileLayer('nether/{z}/{x}/{y}.png', {
				minZoom: mapMinZoom,
				maxZoom: mapMaxZoom,
				noWrap: true,
				tms: false
			});
			
			// Define the protected spawn area.
			// We'll add this to the controls.
			var spawn = L.rectangle([[(-298/coCor), (673/coCor)], [(702/coCor), (-327/coCor)]], {
				color: 'yellow',
				opacity: 0.15,
				weight: 1
			}).bindTooltip('Spawn').bindPopup('Spawn');
			
			var hub = L.rectangle([[(-44/coCor), (-44/coCor)], [(95/coCor), (95/coCor)]], {
				color: 'magenta',
				opacity: 0.15,
				weight: 1
			}).bindTooltip('Hub').bindPopup('Hub');

			// Populate the homes group from the homesList.
			// We'll show it by default but add it to the controls.
			var homes = L.layerGroup([]);
			if( typeof homesList !== 'undefined' ) {
				homesList.forEach( home => {
					homes.addLayer(
						L.circle([(home.y*-1/coCor),(home.x/coCor)], {
							color: 'red',
							opacity: 0.6,
							fillOpacity: 0.6,
							weight: 2,
							radius: 15,
							title: home.name
						}).bindTooltip(home.name).bindPopup(home.name)
					);
				});
			}

			// Populate the warps group from  the warpsList.
			// We'll add this to the controls.
			var warps = L.layerGroup([]);
			if( typeof warpList !== 'undefined' ) {
				warpList.forEach( warp => {
					warps.addLayer(
						L.circle([(warp.y*-1/coCor),(warp.x/coCor)], {
							color: 'yellow',
							opacity: 0.5,
							fillOpacity: 0.5,
							weight: 1,
							radius: 100
						}).bindTooltip(warp.name).bindPopup(warp.name)
					);
				});
			}

			// Create the map with the default layers.
			// By default we show the overworld and homes.
			var map = new L.Map('map', {
				maxZoom: mapMaxZoom,
				minZoom: mapMinZoom,
				layers: [overworld, homes],
				crs: crs
			}).fitBounds([
				crs.unproject(L.point(mapExtent[2], mapExtent[3])),
				crs.unproject(L.point(mapExtent[0], mapExtent[1]))
			]);

			// Define a default search marker and function to draw it.
			// This is done so we got the searchMarker in a variable.
			var searchMarker = L.circleMarker();
			function addSearchMarker(latlng, title, map){
				searchMarker.remove();
				searchMarker = L.circleMarker(latlng, {color:'red'}).addTo(map);
			};

			// Create the different controls and search options.
			// Controll over what is shown is done based on the baselayerchange event.
			var defaultControls = L.control.layers({"Overworld": overworld, "Nether": nether},{"Spawn": spawn, "Warps": warps, "Homes": homes});
			var netherControls = L.control.layers({"Overworld": overworld, "Nether": nether},{"Hub": hub});
			var defaultSearch = new L.Control.Search({
				layer: homes,
				initial: false,
				autoType: false,
				position:'topright',
				marker: false,
				moveToLocation: function(latlng, title, map){addSearchMarker(latlng, title, map)}
			});
			
			// Display the coordinates
			L.control.mousePosition({lngFirst: true, lngFormatter: lng, latFormatter: lat}).addTo(map);
			
			// Add the default controls to the map
			defaultControls.addTo(map);
			map.addControl(defaultSearch);
			
			// Change the controls and search based on the base layer.
			map.on('baselayerchange', function(i){
				searchMarker.remove();
				
				switch(i.name){
					default:
						defaultControls.addTo(map);
						defaultSearch.addTo(map);
						
						netherControls.remove();
						hub.remove();
						break;
					case 'Nether':
						defaultControls.remove();
						defaultSearch.remove();
						spawn.remove();
						warps.remove();
						homes.remove();
						
						netherControls.addTo(map);
						hub.addTo(map);
						break;
				}
			})
		});
    </script>
  </body>
</html>
